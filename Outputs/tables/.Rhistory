header = TRUE)
# factor conversion if below are not in factors
columns<-c("Plot", "Entry", "Replication", "Block", "Row", "Column", "Year")
icar.data.out[, columns]<-lapply(columns, function(x) as.factor(icar.data.out[[x]]))
icar.data.out$GYKGPHA<-as.numeric(icar.data.out$GYKGPHA)
icar.data.out$Height<-as.numeric(icar.data.out$Height)
}
# Create two new columns if design is augmenetd. Used incase checks are used as fixed effects
# Adding a new column 'new' that will help treat genotypes as separate
#icar.data.out$Entry<-as.numeric(icar.data.out$Entry)
#icar.data.out<- within(icar.data.out,{
# new <- ifelse(icar.data.out$Line.type=="check", 0, 1)
#})
# Adding a new column 'entryc' that will help us group all the new entries
# in a single pool, yet treat all checks as separate
#icar.data.out<- within(icar.data.out, {
# entryc <- ifelse(icar.data.out$new > 0, 999, icar.data.out$Entry)
#})
# First we will arrange the Rows and columns for spatial analysis.
# Now we will subset the environments and traits for analysis
icar.data.out<-data.frame(icar.data.out%>% group_by(Environment)%>%arrange(Row, Column)) # arrange by row and column
icar.data.out<-data.frame(icar.data.out%>% arrange(Environment)) # Arrange by environment
icar.dr<-subset(icar.data.out, Environment=="India.ICAR.Drought") # Drought Environment
icar.dr<-droplevels.data.frame(icar.dr)
icar.ns<-subset(icar.data.out, Environment=="India.ICAR.NS") # Non-stress Environment
icar.ns<-droplevels.data.frame(icar.ns)
# Now we will develop function to run the various models and extract AIC values.
# We will select best model based on lower AIC value and residual plots
# Best model will be used to extract the BLUPs
# Note in this data set Block= Rows, not sappropriate!!
my.asreml<-function(data, trait){
# name<- eval(substitute(trait),eval(data))
trait<-data[,trait]
# Model 1: Accouting for just experimental design factors-Block fixed effect
asreml.options(gammaPar = TRUE)
model1<-asreml(fixed=trait~Block, random=~Entry, na.method="include", data=data)
aic.model1<- -2 *model1$loglik +2 *length(model1$vparameters)
plot.model1<-plot(model1)
# Model 2: Accouting for just experimental design factors-Block and Column only- Random effect
model2<-asreml(fixed=trait~1, random=~Column+Block+Entry, na.method="include", data=data)
aic.model2<- -2 *model2$loglik +2 *length(model2$vparameters)
plot.model2<-plot(model2)
# Model 3: Accounting for spatial variations, with block and column effects plus correlated residuals in row and column diretcion
model3<-asreml(fixed=trait~1, random=~Column+Block+Entry,
residual =~ar1v(Block):ar1(Column),  na.method="include", data=data)
aic.model3<- -2*model3$loglik +2*length(model3$vparameters)
plot.model3<-plot(model3)
# Model 4: Accounting for spatial variations in row and column diretcion
asreml.options(gammaPar = TRUE)
model4<-asreml(fixed=trait~Block, random=~Entry,
residual =~ar1v(Block):ar1(Column),  na.method="include", data=data)
aic.model4<- -2*model4$loglik +2*length(model4$vparameters)
plot.model4<-plot(model4)
# Model 5: Accounting for spatial variations in one direction
model5<-asreml(fixed=trait~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=data)
aic.model5<- -2*model5$loglik +2*length(model5$vparameters)
plot.model5<-plot(model5, main = "model5")
AIC.values<-data.frame(model1=aic.model1, model2=aic.model2, model3=aic.model3, model4=aic.model4, model5=aic.model5)
#models<-list( model1,  model2,  model3,  model4, model5)
#all.plots<-list(plot.model1, plot.model1,plot.model1, plot.model1,plot.model1)
return(AIC.values)
}
# Npw run above function to test various models for both environments and traits
# For grain yield under drought
output.dr.gy<-my.asreml(icar.dr, trait = "GYKGPHA")
# Extract the name of model that has lower AIC
best.model.dr.gy<-colnames(output.dr.gy)[apply(output.dr.gy,1,which.min)]
best.model.dr.gy
# For grain yield under non-stress
output.ns.gy<-my.asreml(icar.ns, trait = "GYKGPHA")
# Extract the name of model that has lower AIC
best.model.ns.gy<-colnames(output.ns.gy)[apply(output.ns.gy,1,which.min)]
best.model.ns.gy
best.model.ns.gy
# Now select the best model to extract BLUPs for each trait and environment
# First we will build again a function to extract blups and heritability from best model
my.blup<-function(model, data){
#p<-plot(varioGram(model))
# Now use predict function to return the list of three containing predicted values, and average S.E differnces
predicted.values<-predict(model, "Entry", sed=T)
# Extract the BLUPs from above
blups<-predicted.values$pvals
# Now let us add the line designation names
# BLUPs with line names
#blups<-merge(data[,c(7,8,13,14)],blups, by="Entry")
#blups<-blups[!duplicated(blups$Entry), ]
# Calculate the heritability
# Simply based on the varaince componnets
#heritability<-vpredict(model5, hA ~  V1/(V1 + V2+V3+V4+V5))
#H2<-heritability[1,1]*100
#the Reliazied heritability that is appropriate for complex residual structures and unbalanced experimental designs introduced by Cullis et al. (2006) and discussed by Piepho and M€ohring (2007):
# page 235
# First let us extract the vBLUp differnce
avgsd<-predicted.values$avsed[2]
h2<- (1-((predicted.values$avsed[2])^2/((summary(model)$varcomp[1,1])*2)))*100
return(list(Heritability=h2, BLUPs=blups))
}
# Now for grain yield under drought
best.model.dr.gy
model5.gy.dr<-asreml(fixed=GYKGPHA~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=icar.dr)
# BLUPs and heritability for grain yield under non-stress
out.gy.dr<-my.blup(model5.gy.dr, icar.dr)
out.gy.dr$Heritability
blups.dr.gy<-out.gy.dr$BLUPs
names(blups.dr.gy)[c(2,3)]<-c("blups.gy", "std.er.gy")
# Now for grain yield under non-stress
best.model.ns.gy
model5.gy.ns<-asreml(fixed=GYKGPHA~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=icar.ns)
# BLUPs and heritability for grain yield under drought
out.gy.ns<-my.blup(model5.gy.ns, icar.ns)
out.gy.ns$Heritability
blups.ns.gy<-out.gy.ns$BLUPs
# rename the columns and select appropriate columns
names(blups.ns.gy)[c(2,3)]<-c("blups.gy", "std.er.gy")
# Now let us combine all the BLUPs dataframes into one and save
# Let us add stress information column first
blups.dr<-data.frame(cbind(data.frame(Stress=c(rep("Drought",nrow(blups.dr.gy)))), blups.dr.gy))
# Now add the designation name and line.type
blups.dr<-merge(icar.dr[,c(7,13,14)],blups.dr, by="Entry")
blups.dr<-blups.dr[!duplicated(blups.dr$Entry), ]
# Now combine non-stress
blups.ns<-data.frame(cbind(data.frame(Stress=c(rep("Non-stress",nrow(blups.ns.gy)))), blups.ns.gy))
# Now add the designation name and line.type
blups.ns<-merge(icar.ns[,c(7,13,14)],blups.ns, by="Entry")
blups.ns<-blups.ns[!duplicated(blups.ns$Entry), ]
# Now combine all
blups.all<-rbind(blups.dr[,-7], blups.ns[,-7])
# Round all the columns containing blups and standard errors
blups.all<-data.frame(lapply(blups.all, function(y) if(is.numeric(y)) round(y, 2) else y))
# Save the blups in the directory
write.csv(blups.all,
file="~/Google Drive File Stream/My Drive/Data_analysis/Phenotypic_Data/Rainfed/RCP_2019/scripts/ICAR_Tripura/outputs/blups.all.seperate.csv",
row.names = FALSE)
setwd("~/Documents/manuscript/outputs/tables")
# Now select the best model to extract BLUPs for each trait and environment
# First we will build again a function to extract blups and heritability from best model
my.blup<-function(model, data){
#p<-plot(varioGram(model))
# Now use predict function to return the list of three containing predicted values, and average S.E differnces
predicted.values<-predict(model, "Entry", sed=T)
# Extract the BLUPs from above
blups<-predicted.values$pvals
# Now let us add the line designation names
# BLUPs with line names
#blups<-merge(data[,c(7,8,13,14)],blups, by="Entry")
#blups<-blups[!duplicated(blups$Entry), ]
# Calculate the heritability
# Simply based on the varaince componnets
#heritability<-vpredict(model5, hA ~  V1/(V1 + V2+V3+V4+V5))
#H2<-heritability[1,1]*100
#the Reliazied heritability that is appropriate for complex residual structures and unbalanced experimental designs introduced by Cullis et al. (2006) and discussed by Piepho and M€ohring (2007):
# page 235
# First let us extract the vBLUp differnce
avgsd<-predicted.values$avsed[2]
h2<- (1-((predicted.values$avsed[2])^2/((summary(model)$varcomp[1,1])*2)))*100
return(list(Heritability=h2, BLUPs=blups))
}
# Now for grain yield under drought
best.model.dr.gy
model5.gy.dr<-asreml(fixed=GYKGPHA~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=icar.dr)
# BLUPs and heritability for grain yield under non-stress
out.gy.dr<-my.blup(model5.gy.dr, icar.dr)
out.gy.dr$Heritability
blups.dr.gy<-out.gy.dr$BLUPs
names(blups.dr.gy)[c(2,3)]<-c("blups.gy", "std.er.gy")
# Now for grain yield under non-stress
best.model.ns.gy
model5.gy.ns<-asreml(fixed=GYKGPHA~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=icar.ns)
# BLUPs and heritability for grain yield under drought
out.gy.ns<-my.blup(model5.gy.ns, icar.ns)
out.gy.ns$Heritability
blups.ns.gy<-out.gy.ns$BLUPs
# rename the columns and select appropriate columns
names(blups.ns.gy)[c(2,3)]<-c("blups.gy", "std.er.gy")
# Now let us combine all the BLUPs dataframes into one and save
# Let us add stress information column first
blups.dr<-data.frame(cbind(data.frame(Stress=c(rep("Drought",nrow(blups.dr.gy)))), blups.dr.gy))
# Now add the designation name and line.type
blups.dr<-merge(icar.dr[,c(7,13,14)],blups.dr, by="Entry")
blups.dr<-blups.dr[!duplicated(blups.dr$Entry), ]
# Now combine non-stress
blups.ns<-data.frame(cbind(data.frame(Stress=c(rep("Non-stress",nrow(blups.ns.gy)))), blups.ns.gy))
# Now add the designation name and line.type
blups.ns<-merge(icar.ns[,c(7,13,14)],blups.ns, by="Entry")
blups.ns<-blups.ns[!duplicated(blups.ns$Entry), ]
# Now combine all
blups.all<-rbind(blups.dr[,-7], blups.ns[,-7])
# Round all the columns containing blups and standard errors
blups.all<-data.frame(lapply(blups.all, function(y) if(is.numeric(y)) round(y, 2) else y))
# Save the blups in the directory
write.csv(blups.all,
file="~/Documents/manuscript/outputs/tables/blups.all.seperate.csv",
row.names = FALSE)
# Calcualte summary and heritability
# Save heritability as vector
Heritability<-c(out.gy.dr$Heritability, out.gy.ns$Heritability)
#
summary.gy<-cbind(data.frame(blups.all%>%
group_by(Stress)%>%
summarize(Mean = mean(blups.gy, na.rm=TRUE),
Median= median(blups.gy, na.rm=TRUE),
SD =sd(blups.gy, na.rm=TRUE),
Min.=min(blups.gy, na.rm=TRUE),
Max.=max(blups.gy, na.rm=TRUE))
),Heritability)
# Round
summary.gy<-data.frame(lapply(summary.gy, function(y) if(is.numeric(y)) round(y, 2) else y))
# Plot the data.tables
print_table(summary.gy, rownames = FALSE,caption = htmltools::tags$caption("Data Summaries of BLUPs in Drought and Non-stress trials for Grain Yield ", style="color:black; font-size:130%"))
# Read the saved csv file, if working directly
if(exists('icar.data.out') && is.data.frame(get('icar.data.out'))){
icar.data.out=icar.data.out
}else{
icar.data.out<-read.csv(file="~/Documents/manuscript/outputs/tables/icar.data.filtered.csv",
header = TRUE)
# factor conversion if below are not in factors
columns<-c("Plot", "Entry", "Replication", "Block", "Row", "Column", "Year")
icar.data.out[, columns]<-lapply(columns, function(x) as.factor(icar.data.out[[x]]))
icar.data.out$GYKGPHA<-as.numeric(icar.data.out$GYKGPHA)
icar.data.out$Height<-as.numeric(icar.data.out$Height)
}
# Create two new columns if design is augmenetd. Used incase checks are used as fixed effects
# Adding a new column 'new' that will help treat genotypes as separate
#icar.data.out$Entry<-as.numeric(icar.data.out$Entry)
#icar.data.out<- within(icar.data.out,{
# new <- ifelse(icar.data.out$Line.type=="check", 0, 1)
#})
# Adding a new column 'entryc' that will help us group all the new entries
# in a single pool, yet treat all checks as separate
#icar.data.out<- within(icar.data.out, {
# entryc <- ifelse(icar.data.out$new > 0, 999, icar.data.out$Entry)
#})
# First we will arrange the Rows and columns for spatial analysis.
# Now we will subset the environments and traits for analysis
icar.data.out<-data.frame(icar.data.out%>% group_by(Environment)%>%arrange(Row, Column)) # arrange by row and column
icar.data.out<-data.frame(icar.data.out%>% arrange(Environment)) # Arrange by environment
icar.dr<-subset(icar.data.out, Environment=="India.ICAR.Drought") # Drought Environment
icar.dr<-droplevels.data.frame(icar.dr)
icar.ns<-subset(icar.data.out, Environment=="India.ICAR.NS") # Non-stress Environment
icar.ns<-droplevels.data.frame(icar.ns)
# Now we will develop function to run the various models and extract AIC values.
# We will select best model based on lower AIC value and residual plots
# Best model will be used to extract the BLUPs
# Note in this data set Block= Rows, not sappropriate!!
my.asreml<-function(data, trait){
# name<- eval(substitute(trait),eval(data))
trait<-data[,trait]
# Model 1: Accouting for just experimental design factors-Block fixed effect
asreml.options(gammaPar = TRUE)
model1<-asreml(fixed=trait~Block, random=~Entry, na.method="include", data=data)
aic.model1<- -2 *model1$loglik +2 *length(model1$vparameters)
plot.model1<-plot(model1)
# Model 2: Accouting for just experimental design factors-Block and Column only- Random effect
model2<-asreml(fixed=trait~1, random=~Column+Block+Entry, na.method="include", data=data)
aic.model2<- -2 *model2$loglik +2 *length(model2$vparameters)
plot.model2<-plot(model2)
# Model 3: Accounting for spatial variations, with block and column effects plus correlated residuals in row and column diretcion
model3<-asreml(fixed=trait~1, random=~Column+Block+Entry,
residual =~ar1v(Block):ar1(Column),  na.method="include", data=data)
aic.model3<- -2*model3$loglik +2*length(model3$vparameters)
plot.model3<-plot(model3)
# Model 4: Accounting for spatial variations in row and column diretcion
asreml.options(gammaPar = TRUE)
model4<-asreml(fixed=trait~Block, random=~Entry,
residual =~ar1v(Block):ar1(Column),  na.method="include", data=data)
aic.model4<- -2*model4$loglik +2*length(model4$vparameters)
plot.model4<-plot(model4)
# Model 5: Accounting for spatial variations in one direction
model5<-asreml(fixed=trait~Block, random=~Entry,
residual =~idv(Block):ar1(Column),  na.method="include", data=data)
aic.model5<- -2*model5$loglik +2*length(model5$vparameters)
plot.model5<-plot(model5, main = "model5")
AIC.values<-data.frame(model1=aic.model1, model2=aic.model2, model3=aic.model3, model4=aic.model4, model5=aic.model5)
#models<-list( model1,  model2,  model3,  model4, model5)
#all.plots<-list(plot.model1, plot.model1,plot.model1, plot.model1,plot.model1)
return(AIC.values)
}
summary.gykgpha<-data.frame(icar.data.out %>%
group_by(Environment)%>%
summarize(Mean = mean(GYKGPHA, na.rm=TRUE),
Median= median(GYKGPHA, na.rm=TRUE),
SD =sd(GYKGPHA, na.rm=TRUE),
Min.=min(GYKGPHA, na.rm=TRUE),
Max.=max(GYKGPHA, na.rm=TRUE),
CV=sd(GYKGPHA, na.rm=TRUE)/mean(GYKGPHA, na.rm=TRUE)*100,
St.err= sd(GYKGPHA, na.rm=TRUE)/sqrt(length(GYKGPHA))
))
summary.gykgpha<-data.frame(lapply(summary.gykgpha, function(y) if(is.numeric(y)) round(y, 2) else y))
summary.gykgpha<-cbind(data.frame(Trait=c(rep("Yield", nrow(summary.gykgpha)))),summary.gykgpha )
# Summary for the flowering data
summary.flowering<-data.frame(icar.data.out %>%
group_by(Environment)%>%
summarize(Mean = mean(Days.to.flowering, na.rm=TRUE),
Median= median(Days.to.flowering, na.rm=TRUE),
SD =sd(Days.to.flowering, na.rm=TRUE),
Min.=min(Days.to.flowering, na.rm=TRUE),
Max.=max(Days.to.flowering, na.rm=TRUE),
CV=sd(Days.to.flowering, na.rm=TRUE)/mean(Days.to.flowering, na.rm=TRUE)*100,
St.err= sd(Days.to.flowering, na.rm=TRUE)/sqrt(length(Days.to.flowering))
))
summary.flowering<-data.frame(lapply(summary.flowering, function(y) if(is.numeric(y)) round(y, 2) else y))
summary.flowering<-cbind(data.frame(Trait=c(rep("Flowering", nrow(summary.flowering)))),summary.flowering )
# Summary for plant height
summary.height<-data.frame(icar.data.out %>%
group_by(Environment)%>%
summarize(Mean = mean(Height, na.rm=TRUE),
Median= median(Height, na.rm=TRUE),
SD =sd(Height, na.rm=TRUE),
Min.=min(Height, na.rm=TRUE),
Max.=max(Height, na.rm=TRUE),
CV=sd(Height, na.rm=TRUE)/mean(Height, na.rm=TRUE)*100,
St.err= sd(Height, na.rm=TRUE)/sqrt(length(Height))
))
summary.height<-data.frame(lapply(summary.height, function(y) if(is.numeric(y)) round(y, 2) else y))
summary.height<-cbind(data.frame(Trait=c(rep("Height", nrow(summary.height)))),summary.height )
# Now combine the all data summeries and view as table
summary.data<-rbind(summary.gykgpha, summary.flowering, summary.height)
datatable(summary.data,options = list(pageLength = 7, dom = 'tip'), rownames = FALSE,caption = htmltools::tags$caption("Data summary including mean, median, standard deviation (SD), Coefficient of variation (CV), and Standard error (St.err) for yield, flowering and height", style="color:black; font-size:130%"))
# Save the file for analysis
write.csv(icar.data.out, file = "~/Documents/manuscript/outputs/tables/icar.data.filtered.csv", row.names = FALSE)
# First we will read the filtered data set contianing both drought and non-stress data.
if(exists('icar.data.out') && is.data.frame(get('icar.data.out'))){
icar.data.out=icar.data.out
}else{
icar.data.out<-read.csv(file="~/Documents/manuscript/outputs/tables/icar.data.filtered.csv",
header = TRUE)
}
# In case checks are used as fixed effects
# Create two new columns if design is augmenetd.
# Adding a new column 'new' that will help treat genotypes as separate
#icar.data.out$Entry<-as.numeric(icar.data.out$Entry)
#icar.data.out<- within(icar.data.out,{
#new <- ifelse(icar.data.out$Line.type=="check", 0, 1)
#})
# Adding a new column 'entryc' that will help us group all the new entries
# in a single pool, yet treat all checks as separate
#icar.data.out<- within(icar.data.out, {
# entryc <- ifelse(icar.data.out$new > 0, 999, icar.data.out$Entry)
#})
# Arrange the the data set before running it
icar.data.out<-data.frame(icar.data.out%>% group_by(Environment)%>%arrange(Row, Column))
icar.data.out<-icar.data.out%>% arrange(Environment)
columns<-c("Plot", "Entry", "Replication", "Block", "Row", "Column", "Year")
icar.data.out[, columns]<-lapply(columns, function(x) as.factor( icar.data.out[[x]]))
icar.data.out$GYKGPHA<-as.numeric(icar.data.out$GYKGPHA)
# Here we will perform combined analysis of data, by combining drought and non-stress
# Spatial variation model will be used, model will be selected based on previous analysis done seperately under dr..
# For GRAIN YIELD
met.gy<-asreml(GYKGPHA ~1,random= ~Entry +Environment:Entry+Block:Environment,
residual =~dsum(~idv(Block):ar1(Column)+idv(Block):ar1(Column)|Environment,levels = list(c(1), c(2))), na.method ="include", data = icar.data.out)
summary(met.gy)$varcomp
#aic<- -2*(model.met2$loglik-length(model.met2$vparameters));aic
predicted.gy<-predict(met.gy, "Entry", sed=T)
# Extract the BLUPs from above
blups.gy.met<-predicted.gy$pvals
names(blups.gy.met)[c(2,3)]<-c("blups.gy", "std.er.gy")
# Now calculate heritability
h2.gy.met<- (1-((predicted.gy$avsed[2])^2/((summary(met.gy)$varcomp[2,1])*2)))*100;h2.gy.met
# Now add designation and line.type to blup file
# Now add the designation name and line.type
blups.met<-merge(icar.dr[,c(7,13,14)],blups.gy.met[,-4], by="Entry")
blups.met<-blups.met[!duplicated(blups.met$Entry), ]
blups.met<-data.frame(lapply(blups.met, function(y) if(is.numeric(y)) round(y, 2) else y))
# Blups table
print_table(blups.met,editable = 'cell', rownames = FALSE,caption = htmltools::tags$caption(" Combined BLUPs along with Standard errors for Grain Yield ", style="color:black; font-size:130%"))
# Save the blup file
write.csv(blups.met,
file="~/Documents/manuscript/outputs/tables/blups.combined.csv",
row.names = FALSE)
# Blups table
print_table(blups.met[, c(1,3,4,5)],editable = 'cell', rownames = FALSE,caption = htmltools::tags$caption(" Combined BLUPs along with Standard errors for Grain Yield ", style="color:black; font-size:130%"))
# Save the blup file
write.csv(blups.met,
file="~/Documents/manuscript/outputs/tables/blups.combined.csv",
row.names = FALSE)
summary.met.gy<-data.frame(blups.met%>%
group_by(Line.type)%>%
summarize(Mean = mean(blups.gy, na.rm=TRUE),
Median= median(blups.gy, na.rm=TRUE),
SD =sd(blups.gy, na.rm=TRUE),
Min.=min(blups.gy, na.rm=TRUE),
Max.=max(blups.gy, na.rm=TRUE),
Heritability=h2.gy.met)
)
summary.met.gy<-data.frame(lapply(summary.met.gy, function(y) if(is.numeric(y)) round(y, 2) else y))
summary.met.gy[1,7]<-"-"
print_table(summary.met.gy, rownames = FALSE)
# Ranking and selection of top performing lines
# Subset only entries
blups.met.entry<-subset(blups.met, Line.type=="entry")
# Get mean of entries and checks
entry.mean<-mean(blups.met.entry$blups.gy)
check.mean<-mean((subset(blups.met, Line.type=="check"))$blups.gy)
# Arrange the BLUPs in decreasing order
blups.met.entry<-blups.met.entry%>%arrange(desc(blups.gy))
# Select top 35 and merge with checks
blups.top25<-data.frame(rbind((blups.met.entry[1:35, ]), (subset(blups.met, Line.type=="check"))))
blups.top25<-droplevels.data.frame(blups.top25)
# make factor unique to keep order of entries on plot
blups.top25$B4R.designation <- factor(blups.top25$B4R.designation, levels=unique(blups.top25$B4R.designation))
# Draw the plot
bar.plot<-ggplot(data=blups.top25, aes(x=B4R.designation, y=blups.gy, fill=Line.type)) +
geom_bar(stat="identity", width=0.5)+
theme_classic()+
labs(title="BLUPs of Top Ranked Genotypes along with Checks",x="B4R.designation", y = "BLUP Value")+
#scale_y_continuous(limits = c(0, 6000), breaks = seq(0, 6000, by = 500))+
theme (plot.title = element_text(color="black", size=1, face="bold", hjust=0),
axis.title.x = element_text(color="black", size=10, face="bold"),
axis.title.y = element_text(color="black", size=10, face="bold")) +
theme(axis.text= element_text(color = "black", size = 8))+
geom_segment(aes(x = 1, y = entry.mean, xend = 35, yend =entry.mean), color="darkred",
linetype="dashed", size=1)+
geom_segment(aes(x = 36, y = check.mean, xend = 47, yend =check.mean), color="darkblue",
linetype="dashed", size=1)+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplotly(bar.plot)
View(blups.top25)
# Ranking and selection of top performing lines
# Subset only entries
blups.met.entry<-subset(blups.met, Line.type=="entry")
# Get mean of entries and checks
entry.mean<-mean(blups.met.entry$blups.gy)
check.mean<-mean((subset(blups.met, Line.type=="check"))$blups.gy)
# Arrange the BLUPs in decreasing order
blups.met.entry<-blups.met.entry%>%arrange(desc(blups.gy))
# Select top 35 and merge with checks
blups.top25<-data.frame(rbind((blups.met.entry[1:35, ]), (subset(blups.met, Line.type=="check"))))
blups.top25<-droplevels.data.frame(blups.top25)
# make factor unique to keep order of entries on plot
blups.top25$B4R.designation <- factor(blups.top25$B4R.designation, levels=unique(blups.top25$B4R.designation))
blups.top25$Entry <- factor(blups.top25$Entry, levels=unique(blups.top25$Entry))
# Draw the plot
bar.plot<-ggplot(data=blups.top25, aes(x=Entry, y=blups.gy, fill=Line.type)) +
geom_bar(stat="identity", width=0.5)+
theme_classic()+
labs(title="BLUPs of Top Ranked Genotypes along with Checks",x="B4R.designation", y = "BLUP Value")+
#scale_y_continuous(limits = c(0, 6000), breaks = seq(0, 6000, by = 500))+
theme (plot.title = element_text(color="black", size=1, face="bold", hjust=0),
axis.title.x = element_text(color="black", size=10, face="bold"),
axis.title.y = element_text(color="black", size=10, face="bold")) +
theme(axis.text= element_text(color = "black", size = 8))+
geom_segment(aes(x = 1, y = entry.mean, xend = 35, yend =entry.mean), color="darkred",
linetype="dashed", size=1)+
geom_segment(aes(x = 36, y = check.mean, xend = 47, yend =check.mean), color="darkblue",
linetype="dashed", size=1)+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplotly(bar.plot)
# Blups in drought
blups.dr<-subset(blups.all, Stress=="Drought", select =c(1,5))
colnames(blups.dr)<-c("Entry", "BLUPs.drought")
# Blups in non-stress data
blups.ns<-subset(blups.all, Stress=="Non-stress", select =c(1,5))
colnames(blups.ns)<-c("Entry", "BLUPs.non-stress")
# now combined blups
blups.com<-blups.met[, c(1,2,4)]
colnames(blups.com)<-c("Entry", "B4R.designation", "BLUPs.combined")
# Merge all the BLUPs
blups.com.all<-merge((merge(blups.dr, blups.ns, by="Entry")), (blups.com), by="Entry")
corr.blup <- data.frame(round(cor(blups.com.all[,-c(1,4)]), 2))
print_table(corr.blup, rownames = TRUE, caption = htmltools::tags$caption("Correlation of BLUPs obtained through Drought, Non-stress and Combined Analysis.", style="color:black; font-size:130%"))
# Combined blups
com.blups.top<-subset(blups.met, Line.type=="entry")
com.blups.top<-com.blups.top%>%arrange(desc(blups.gy))
com.blups.top<-com.blups.top[1:35,]
colnames(com.blups.top)[1]<-"Entry.com"
# Blups in drought
blups.dr<-subset(blups.all, Stress=="Drought", select =c(1,5))
blups.dr.top<-blups.dr%>%arrange(desc(blups.gy))
blups.dr.top<-blups.dr.top[1:35,]
colnames(blups.dr.top)[1]<-"Entry.dr"
# Blups in non-stress
blups.ns<-subset(blups.all, Stress=="Non-stress", select =c(1,5))
blups.ns.top<-blups.ns%>%arrange(desc(blups.gy))
blups.ns.top<-blups.ns.top[1:35,]
colnames(blups.ns.top)[1]<-"Entry.ns"
# Now cbinb all the required columns
data.venn<-data.frame(cbind(Combined=com.blups.top$Entry.com, Drought=blups.dr.top$Entry.dr, Non.stress=blups.ns.top$Entry.ns))
library(RColorBrewer)
myCol <- brewer.pal(3, "Pastel2")
P<-venn.diagram(
x = list(data.venn$Combined, data.venn$Drought, data.venn$Non.stress),
category.names = c("Combined.BLUPs" , "Drought.BLUPs " , "Non.Stress.BLUPs"),
filename = '~/Google Drive File Stream/My Drive/Data_analysis/Phenotypic_Data/Rainfed/RCP_2019/scripts/ICAR_Tripura/14_venn_diagramm.png',
output=TRUE,
# Output features
imagetype="png" ,
height = 1200 ,
width = 1200 ,
resolution = 500,
# Circles
lwd = 2,
lty = 'blank',
fill = myCol,
# Numbers
cex = .6,
fontface = "bold",
fontfamily = "sans",
# Set names
cat.cex = 0.2,
cat.fontface = "bold",
cat.default.pos = "outer",
cat.pos = c(-27, 27, 135),
cat.dist = c(0.055, 0.055, 0.085),
cat.fontfamily = "sans",
rotation = 1
)
P
